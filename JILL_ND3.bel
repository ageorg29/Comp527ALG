% author : Aina Linn Georges
% date : 04/06/2016 
% 
% JILL (natural deduction) 


% Defining propositions
LF o : type =
| top : o
| one : o
| zero : o
| aAnd : o -> o -> o
| aOr : o -> o -> o
| mImp : o -> o -> o
| mAnd : o -> o -> o
| excl : o -> o
| intr : o -> o
; 

% Defining judgments 
LF j : type = 
| true : o -> j
| poss : o -> j
;

% Defining goal/poss
LF g : type = 
| goal : o -> g
| poss_g : o -> g
;

% Defining assumptions
LF asmp : o -> type = 
| int_asmp : asmp A
;

% defining contexts
LF linctx : type = 
| empty : linctx
| cons : linctx -> o -> linctx -> linctx
;

% defining merging
LF merge : linctx -> linctx -> linctx -> type = 
| e_m : merge empty C C
| e_c : merge C1 C C' -> merge (cons C1 A C2) C (cons C' A C2)
;

% defining assumption add
LF added : linctx -> o -> linctx -> type = 
| e_a : added empty A (cons empty A empty)
| c_a : added C A C' -> added (cons C B C'') A (cons C' B C'') 
;


% --------------------- JILL natural deduction ---------------------

LF jillnd : linctx -> o -> type =
| hyp : jillnd (cons empty A empty) A
| hypexcl : asmp A -> jillnd empty A
| aAndI : jillnd G A -> jillnd G B -> jillnd G (aAnd A B)
| aAndEl : jillnd G (aAnd A B) -> jillnd G A
| aAndEr : jillnd G (aAnd A B) -> jillnd G B
| aOrIl : jillnd G A -> jillnd G (aOr A B)
| aOrIr : jillnd G B -> jillnd G (aOr A B)
| mAndI : jillnd G A -> jillnd G' B -> merge G G' G'' -> jillnd G'' (mAnd A B)
| mImpI : jillnd (cons G A G') B -> merge G G' G'' -> jillnd G'' (mImp A B)
| mImpE : jillnd G (mImp A B) -> jillnd G' A -> merge G G' G'' -> jillnd G'' B
| oneI : jillnd empty one
| topI : jillnd G top
| exclI : jillnd empty A -> jillnd empty (excl A)
| intrI : jillndj G (poss A) -> jillnd G (intr A)

and jillndj : linctx -> j -> type =
| aOrE : jillnd G (aOr A B) -> added G' A G1 -> added G' B G2 -> jillndj G1 J -> jillndj G2 J -> merge G G' G'' -> jillndj G'' J
| mAndE : jillnd G (mAnd A B) -> added G' A G1 -> added G1 B G2 -> jillndj G2 J -> merge G G' G'' -> jillndj G'' J
| oneE : jillnd G one -> jillndj G' J -> merge G G' G'' -> jillndj G'' J
| zeroE : jillnd G zero -> merge G G' G'' -> jillndj G'' J
| possI : {A:o} jillndj G (true A) -> jillndj G (poss A)
| exclE : jillnd G (excl A) -> (asmp A -> jillndj G' J) -> merge G G' G'' -> jillndj G'' J
| intrE : {C:o} jillnd G (intr A) -> jillndj (cons empty A empty) (poss C) -> jillndj G (poss C)
;



% --------------------- JILL sequent calculus ---------------------

LF jillseq : linctx -> o -> type = 
| copy : asmp A -> added G A G' -> jillseq G' A -> jillseq G A
| mAndL : added G A G1 -> added G1 B G2 -> jillseq G2 C -> added G (mAnd A B) G' -> jillseq G' C
| oneL : jillseq G A -> added G1 one G2 -> jillseq G2 A
| mImpL : jillseqg G (goal A) -> added G' B G1 -> jillseq G1 C -> merge G G' G2 -> added G2 (mImp A B) G'' -> jillseq G'' C
| aAndLl : added G A G' -> jillseq G' C -> added G (aAnd A B) G'' -> jillseq G'' C
| aAndLr : added G B G' -> jillseq G' C -> added G (aAnd A B) G'' -> jillseq G'' C
| zeroL : added G zero G' -> jillseq G' C
| aOrL : added G A G1 -> added G B G2 -> jillseq G1 C -> jillseq G2 C -> added G (aOr A B) G' -> jillseq G' C
| exclL : (asmp A -> jillseq G C) -> added G (excl A) G' -> jillseq G' C

and jillseqg : linctx -> g -> type = 
| init : jillseqg (cons empty A empty) (goal A)
| promote : jillseqg G (goal A) -> jillseqg G (poss_g A)
| mAndR : jillseqg G (goal A) -> jillseqg G' (goal B) -> merge G G' G'' -> jillseqg G'' (goal (mAnd A B)) 
| oneR : jillseqg empty (goal one)
| mImpR : added G A G' -> jillseqg G' (goal B) -> jillseqg G (goal (mImp A B))
| aAndR : jillseqg G (goal A) -> jillseqg G (goal B) -> jillseqg G (goal (aAnd A B))
| topR : jillseqg G (goal top)
| aOrRl : jillseqg G (goal A) -> jillseqg G (goal (aOr A B))
| aOrRl : jillseqg G (goal B) -> jillseqg G (goal (aOr A B))
| exclR : jillseqg empty (goal A) -> jillseqg empty (goal (excl A))
| intrL : jillseqg (cons empty A empty) (poss_g C) -> jillseqg (cons empty (intr A) empty) (poss_g C)
| intrR : jillseqg G (poss_g A) -> jillseqg G (goal (intr A))
;